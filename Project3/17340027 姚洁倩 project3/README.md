# Project3 Huffman tree 
## 实现功能
1. 给定频率进行编码和解码
2. 计算频率进行编码和解码



## 运行方法

在命令行下运行make命令

使用./huffman 运行文件

## 主要模块
1.
- 读取给定频率的文件，依次读取各个字符和它们的频率，并且建立叶节点（有权重信息和字符信息，叶节点的len_设置为1），将他们存储到一个数组里面
- 读取不给定频率的文件，使用一个数组记录，边读文件边计算各个字符出现的次数，作为它们的权重。读完之后再建立叶节点，存到一个数组里面。 
2. 利用这个数组，依次选取里面最小权重的两个节点，建立一个新节点。并在数组中删去旧的两个节点，以及放入新的节点。在此过程中，修改新节点的左右子树信息和旧节点的父节点信息。以及计算出新节点的len_信息（用于凹入打印二叉树）。重复此过程，可建立一个哈夫曼树，得到哈夫曼树的根节点。
3. 从哈夫曼树的父节点，开始遍历这棵树，在遍历的过程中，更新各个节点的编码值（左边为0，右边为1）若发现这个节点是叶子节点，那么将这个字符和它对应的编码信息存进一个map里面（编码作为key），另外，在一个数组里面也存一份（索引是字符的ascii码值，内容是编码）
4. 加密过程：读取明文，利用数组中的信息对明文进行加密，将加密后的内容输出到密文文件中
5. 解密过程：读取密文，利用map中的信息解密。由于哈夫曼编码是前缀编码，一旦发现可以解密的编码串，便对这个串进行相应的解密。

## 函数解释

- setUpTree(node* arr[], int n): arr[]中储存了各节点的频率和字符等信息（开始时都为叶节点，长度为1），此函数挑选出arr中最小权重的两棵树，建立起新的树，更新它的长度值（为两棵子树长度之和）。删去原有的两个树，并把新的树加到数组，直到数组中只剩一棵树，那么这个数组储存的节点就是所建立的哈夫曼树的根节点，使用private的root存储这个根节点
- traverseAddCode():在建立好树的基础上，遍历这棵树，给叶节点进行哈夫曼编码。每个节点都存有到此节点为止的一个临时编码，每个节点的左子节点临时编码是其父节点临时编码的基础上加一个‘0’形成的，而右子节点则是加‘1’，那么到达叶节点时，这个临时编码的值恰为叶节点的哈夫曼编码值。在private中使用一个map，建立编码和字符的一一对应关系（编码作为key），以便进行解码，同时也使用了一个code[]的string类型的数组，可随机访问字符的对应编码，在对明文的编码时可以使用。
- encodeFile():对明文进行加密，在明文中一个个读取字符，在private的code数组中获取字符所对应的编码值，将其写入密文文件中。在这个过程中，计算哈夫曼编码文件的总长度，和定长编码相除，得到压缩率。（假设定长编码需要6位，这个可以编码64个字符，是符合要求的最短长度【26+26+4 = 56】）
- decode(): 在建立好的哈夫曼树的基础上，鉴于前面已经建立出了编码对应的字符的映射，在密文文件中一个个读取字符，暂时先添加到一个临时的字符串中，检查这个编码串有无对应的字符解码。若有，则把解码写入明文文件，并将临时字符串情空；若没有，则往临时字符串中继续添加一个字符，以此类推。
- encodeGivenFrequency():在给定频率的条件下，读入存储个字符频率的文件，建立一个个叶子节点，存储到arr[]数组中。并使用setUpTree，traverseAddCode等函数进行哈夫曼编码。使用encodeFile编码明文。
- encodeFindFrequency():遍历这个明文文件，统计个字符的出现次数，用一个数组存起来，索引是字符ascii码，内容是其出现次数。然后利用这个数组里面的信息，建立一个个叶子节点，存储到arr[]数组中。并使用setUpTree，traverseAddCode等函数进行哈夫曼编码。使用encodeFile编码明文。
- printTree(node* n):前序遍历这棵树，并使用凹入表示法打印这棵树。
- getRoot():返回哈夫曼树根节点 
- showCodes()：把每个字符对应的哈夫曼编码打印出来。



## 运行截图

![](1.jpg)

![](2.jpg)

![](3.jpg)

![](4.jpg)

![](5.jpg)

## 其他说明

- frequency.in文件是读入频率的文件(频率是自己随机给的)
- mingwen.in文件是明文的文件,可修改
- miwen.in文件是存储密文的文件
- mingwen2.in文件是解开密文之后的文件



